/*
 * Flash.c
 *
 *  Created on: Nov 5, 2024
 *      Author: Chris
 */

#include "Libraries/Flash.h"


/*! \var HAL_StatusTypeDef flash_status
    \brief Status de operaciones con la FLASH
*/
HAL_StatusTypeDef flash_status;


/**
  * @fn		HAL_StatusTypeDef FLASH_unlock(void)
  * @brief  Funcion para desbloquear la FLASH.
  * @param 	None
  * @retval Status de la operacion
  */
HAL_StatusTypeDef FLASH_unlock(void)
{
	HAL_StatusTypeDef unlock_status;
	unlock_status = HAL_FLASH_Unlock();
	return unlock_status;
}

/**
  * @fn		HAL_StatusTypeDef FLASH_lock(void)
  * @brief  Funcion para bloquear la FLASH.
  * @param 	None
  * @retval Status de la operacion
  */
HAL_StatusTypeDef FLASH_lock(void)
{
	HAL_StatusTypeDef lock_status;
	lock_status = HAL_FLASH_Lock();
	return lock_status;
}

/**
  * @fn		HAL_StatusTypeDef FLASH_cleanPage(uint8_t ucNumPage)
  * @brief  Funcion que borra el contenido de la pagina indicada.
  * @param 	ucNumPage Numero de pagina cuyo contenido sera borrado
  * @retval Status de la operacion
  * @note 	Se debe asegurar el correcto borrado esperando que la operacion se complete.
  */
HAL_StatusTypeDef FLASH_cleanPage(uint8_t ucNumPage)
{

	flash_status = FLASH_unlock();
	FLASH_PageErase(ucNumPage, FLASH_BANK_SELECTED);
	CLEAR_BIT(FLASH->CR, (FLASH_CR_PER));
	FLASH_WaitForLastOperation(FLASH_clear_time);
	FLASH_lock();


	return flash_status;
}

/**
  * @fn		HAL_StatusTypeDef FLASH_read(uint32_t mem_address, uint16_t length, uint8_t *data)
  * @brief  Funcion para leer informacion plasmada en la FLASH a partir de una direccion de memoria.
  * @param 	mem_address Direccion de memoria
  * @param  length Longitud en bytes de la informacion a leer
  * @param	data Estructura de datos en la que se almacenara la lectura
  * @retval Status de la operacion
  */
HAL_StatusTypeDef FLASH_read(uint32_t mem_address, uint16_t length, uint8_t *data)
{
	flash_status = FLASH_unlock();

	for (uint8_t ucNumByte = 0; ucNumByte < length; ucNumByte++)
	{
		data[ucNumByte] = *(uint32_t*) (mem_address + ucNumByte);
	}
	FLASH_lock();

	return flash_status;
}

/**
  * @fn		HAL_StatusTypeDef FLASH_write(uint32_t mem_address, uint16_t length, uint8_t *data)
  * @brief  Funcion para escribir informacion a partir de una direccion de memoria en la FLASH.
  * @param 	mem_address Direccion de memoria
  * @param  length Longitud en bytes de la informacion a escribir
  * @param	data Estructura de datos que contiene los datos a escribir
  * @retval Status de la operacion
  */
HAL_StatusTypeDef FLASH_write(uint32_t mem_address, uint16_t length, uint8_t *data)
{
	uint8_t ucNumWord = 0;
	u64_t buffer;
	do
	{
		for(uint8_t ucNumByte = 0; ucNumByte < 8; ucNumByte++)
		{
			buffer.byte[ucNumByte] = data[ucNumWord + ucNumByte];
		}
		flash_status = FLASH_unlock();
		HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, mem_address + ucNumWord, buffer.u64);
		CLEAR_BIT (FLASH->CR, (FLASH_CR_PG));
		FLASH_lock();
		ucNumWord = ucNumWord + 8;
	} while(ucNumWord < length);

	return flash_status;
}
